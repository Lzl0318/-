// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_ANT_GENERATED_COTRAIN_COTRAIN_H_
#define FLATBUFFERS_ANT_GENERATED_COTRAIN_COTRAIN_H_

#include "flatbuffers/flatbuffers.h"
#include "mybuffer/mybuffer.h"
#include "co_train_generated.h"
#include "mybuffer/wasmlib.h"

namespace cotrain {

struct CoTrainM;
typedef flatbuffers::Offset<CoTrain> CoTrainMOffset;
typedef std::shared_ptr<CoTrainM> CoTrainMPtr;
typedef std::shared_ptr<MyVector<CoTrainM, CoTrainT> > CoTrainMVectorPtr;
typedef std::shared_ptr<MyMap<CoTrainM> > CoTrainMMapPtr;
typedef std::shared_ptr<MyMapIterable<CoTrainM> > CoTrainMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<CoTrainM> > CoTrainMMapKeyIterator;

struct GlobalmodelM;
typedef flatbuffers::Offset<Globalmodel> GlobalmodelMOffset;
typedef std::shared_ptr<GlobalmodelM> GlobalmodelMPtr;
typedef std::shared_ptr<MyVector<GlobalmodelM, GlobalmodelT> > GlobalmodelMVectorPtr;
typedef std::shared_ptr<MyMap<GlobalmodelM> > GlobalmodelMMapPtr;
typedef std::shared_ptr<MyMapIterable<GlobalmodelM> > GlobalmodelMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<GlobalmodelM> > GlobalmodelMMapKeyIterator;

struct ClientM;
typedef flatbuffers::Offset<Client> ClientMOffset;
typedef std::shared_ptr<ClientM> ClientMPtr;
typedef std::shared_ptr<MyVector<ClientM, ClientT> > ClientMVectorPtr;
typedef std::shared_ptr<MyMap<ClientM> > ClientMMapPtr;
typedef std::shared_ptr<MyMapIterable<ClientM> > ClientMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<ClientM> > ClientMMapKeyIterator;

struct CoTrainM : public MyTable<CoTrainT, CoTrain> {
private: 
  std::weak_ptr<MyMap<cotrain::ClientM> > clients_;
  std::weak_ptr<cotrain::GlobalmodelM> globalmodel_;
  using MyTable<CoTrainT, CoTrain>::MyTable;
  friend class MyFactory<CoTrainM, CoTrainT>;
  friend class MyFactory<CoTrainM>;
public: 
  ~CoTrainM() {}
  cotrain::ClientMMapPtr get_clients() {
    cotrain::ClientMMapPtr rv;
    rv = clients_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<cotrain::ClientM> >::make_instance(mychain_lib_ptr_, 
          base_key_->get_table_field_key(FieldNodeType::MAP_V2, 0/*field_id*/, "clients"/*field_name*/), get_self_ptr());
      clients_ = rv;
    }
    return rv;
  }
  cotrain::GlobalmodelMPtr get_globalmodel() {
    cotrain::GlobalmodelMPtr rv;
    rv = globalmodel_.lock();
    if (!rv) {
      rv = MyFactory<cotrain::GlobalmodelM, cotrain::GlobalmodelT>::make_instance(mychain_lib_ptr_, 
        base_key_->get_table_field_key(FieldNodeType::TABLE, 1/*field_id*/), native_table_ptr_->globalmodel, get_self_ptr());
      globalmodel_ = rv;
    }
    return rv;
  }
  std::string get_status() {
    return native_table_ptr_->status;
  }
  bool set_status(std::string _status) {
    uint32_t size_limit = 0 ? 0 : kDefaultStringSizeLimit;
    if( _status.length() > size_limit ) {
        std::string msg = "The string size is over the limit" + std::to_string(size_limit);
        mychain_lib_ptr_->MYLOG(LogLevel::kError, msg);
        mychain_lib_ptr_->MyRevert(msg);
    }
    set_dirty(true);
    native_table_ptr_->status = std::move(_status);
    return true;
  }
};

struct GlobalmodelM : public MyTable<GlobalmodelT, Globalmodel> {
private: 
  using MyTable<GlobalmodelT, Globalmodel>::MyTable;
  friend class MyFactory<GlobalmodelM, GlobalmodelT>;
  friend class MyFactory<GlobalmodelM>;
public: 
  ~GlobalmodelM() {}
  std::string get_model() {
    return native_table_ptr_->model;
  }
  bool set_model(std::string _model) {
    uint32_t size_limit = 1000000 ? 1000000 : kDefaultStringSizeLimit;
    if( _model.length() > size_limit ) {
        std::string msg = "The string size is over the limit" + std::to_string(size_limit);
        mychain_lib_ptr_->MYLOG(LogLevel::kError, msg);
        mychain_lib_ptr_->MyRevert(msg);
    }
    set_dirty(true);
    native_table_ptr_->model = std::move(_model);
    return true;
  }
};

struct ClientM : public MyTable<ClientT, Client> {
private: 
  using MyTable<ClientT, Client>::MyTable;
  friend class MyFactory<ClientM, ClientT>;
  friend class MyFactory<ClientM>;
public: 
  ~ClientM() {}
  bool get_upload() {
    return native_table_ptr_->upload;
  }
  bool set_upload(bool _upload) {
    set_dirty(true);
    native_table_ptr_->upload = _upload;
    return true;
  }
  bool get_download() {
    return native_table_ptr_->download;
  }
  bool set_download(bool _download) {
    set_dirty(true);
    native_table_ptr_->download = _download;
    return true;
  }
  std::string get_localmodel() {
    return native_table_ptr_->localmodel;
  }
  bool set_localmodel(std::string _localmodel) {
    uint32_t size_limit = 1000000 ? 1000000 : kDefaultStringSizeLimit;
    if( _localmodel.length() > size_limit ) {
        std::string msg = "The string size is over the limit" + std::to_string(size_limit);
        mychain_lib_ptr_->MYLOG(LogLevel::kError, msg);
        mychain_lib_ptr_->MyRevert(msg);
    }
    set_dirty(true);
    native_table_ptr_->localmodel = std::move(_localmodel);
    return true;
  }
};

inline CoTrainMPtr GetCoTrainM() {
  static std::weak_ptr<CoTrainM> wp;
  CoTrainMPtr sp;
  sp = wp.lock();
  if (!sp) {
    std::string key = "root_contract_CoTrain";
    std::shared_ptr<MychainLib> mychain_lib_ptr = std::make_shared<WasmLib>();
    mychain_lib_ptr->SetAllowDotInMapKey(false);
    mychain_lib_ptr->SetManualCommit(false);
    std::unique_ptr<Key> root_key = Key::get_root_table_key(key, mychain_lib_ptr);
    std::string buf;
    int ret = mychain_lib_ptr->MyGetStorage(root_key->to_string(), buf);
    if(ret != 0) {
      return nullptr;
    }
    sp = MyFactory<CoTrainM>::make_instance(mychain_lib_ptr, buf, std::move(root_key) /*, nullptr*/);
    wp = sp;
  }
  return sp;
}

inline int InitRoot() {
    std::string key = "root_contract_CoTrain";
    std::shared_ptr<MychainLib> mychain_lib_ptr = std::make_shared<WasmLib>();
    mychain_lib_ptr->SetAllowDotInMapKey(false);
    mychain_lib_ptr->SetManualCommit(false);
    std::unique_ptr<Key> root_key = Key::get_root_table_key(key, mychain_lib_ptr);
    std::string buf;
    int ret = mychain_lib_ptr->MyGetStorage(root_key->to_string(), buf);
    if(ret == 0) {
        std::string msg = "MyBuffer has been already initialized.";
        mychain_lib_ptr->MYLOG(LogLevel::kError, msg);
        mychain_lib_ptr->MyRevert(msg);
    }
    CoTrainMPtr proot = MyFactory<CoTrainM>::make_instance(mychain_lib_ptr, std::move(root_key) /*, nullptr*/);
    return 0;
}

}  // namespace cotrain

#endif  // FLATBUFFERS_ANT_GENERATED_COTRAIN_COTRAIN_H_
