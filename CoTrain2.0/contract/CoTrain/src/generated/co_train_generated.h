// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COTRAIN_COTRAIN_H_
#define FLATBUFFERS_GENERATED_COTRAIN_COTRAIN_H_

#include "flatbuffers/flatbuffers.h"

namespace cotrain {

struct CoTrain;
struct CoTrainBuilder;
struct CoTrainT;

struct Globalmodel;
struct GlobalmodelBuilder;
struct GlobalmodelT;

struct Client;
struct ClientBuilder;
struct ClientT;

struct CoTrainT : public flatbuffers::NativeTable {
  typedef CoTrain TableType;
  std::vector<std::unique_ptr<cotrain::ClientT>> clients;
  std::unique_ptr<cotrain::GlobalmodelT> globalmodel;
  std::string status;
  CoTrainT() {
  }
};

struct CoTrain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoTrainT NativeTableType;
  typedef CoTrainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENTS = 4,
    VT_GLOBALMODEL = 6,
    VT_STATUS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>> *clients() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>> *>(VT_CLIENTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>> *mutable_clients() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>> *>(VT_CLIENTS);
  }
  const cotrain::Globalmodel *globalmodel() const {
    return GetPointer<const cotrain::Globalmodel *>(VT_GLOBALMODEL);
  }
  cotrain::Globalmodel *mutable_globalmodel() {
    return GetPointer<cotrain::Globalmodel *>(VT_GLOBALMODEL);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  flatbuffers::String *mutable_status() {
    return GetPointer<flatbuffers::String *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENTS) &&
           verifier.VerifyVector(clients()) &&
           verifier.VerifyVectorOfTables(clients()) &&
           VerifyOffset(verifier, VT_GLOBALMODEL) &&
           verifier.VerifyTable(globalmodel()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           verifier.EndTable();
  }
  CoTrainT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CoTrainT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CoTrain> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoTrainT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CoTrainBuilder {
  typedef CoTrain Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clients(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>>> clients) {
    fbb_.AddOffset(CoTrain::VT_CLIENTS, clients);
  }
  void add_globalmodel(flatbuffers::Offset<cotrain::Globalmodel> globalmodel) {
    fbb_.AddOffset(CoTrain::VT_GLOBALMODEL, globalmodel);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(CoTrain::VT_STATUS, status);
  }
  explicit CoTrainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CoTrainBuilder &operator=(const CoTrainBuilder &);
  flatbuffers::Offset<CoTrain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CoTrain>(end);
    return o;
  }
};

inline flatbuffers::Offset<CoTrain> CreateCoTrain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<cotrain::Client>>> clients = 0,
    flatbuffers::Offset<cotrain::Globalmodel> globalmodel = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0) {
  CoTrainBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_globalmodel(globalmodel);
  builder_.add_clients(clients);
  return builder_.Finish();
}

inline flatbuffers::Offset<CoTrain> CreateCoTrainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<cotrain::Client>> *clients = nullptr,
    flatbuffers::Offset<cotrain::Globalmodel> globalmodel = 0,
    const char *status = nullptr) {
  auto clients__ = clients ? _fbb.CreateVector<flatbuffers::Offset<cotrain::Client>>(*clients) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return cotrain::CreateCoTrain(
      _fbb,
      clients__,
      globalmodel,
      status__);
}

flatbuffers::Offset<CoTrain> CreateCoTrain(flatbuffers::FlatBufferBuilder &_fbb, const CoTrainT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GlobalmodelT : public flatbuffers::NativeTable {
  typedef Globalmodel TableType;
  std::string model;
  GlobalmodelT() {
  }
};

struct Globalmodel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GlobalmodelT NativeTableType;
  typedef GlobalmodelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL = 4
  };
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  flatbuffers::String *mutable_model() {
    return GetPointer<flatbuffers::String *>(VT_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           verifier.EndTable();
  }
  GlobalmodelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GlobalmodelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Globalmodel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobalmodelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GlobalmodelBuilder {
  typedef Globalmodel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(Globalmodel::VT_MODEL, model);
  }
  explicit GlobalmodelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GlobalmodelBuilder &operator=(const GlobalmodelBuilder &);
  flatbuffers::Offset<Globalmodel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Globalmodel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Globalmodel> CreateGlobalmodel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> model = 0) {
  GlobalmodelBuilder builder_(_fbb);
  builder_.add_model(model);
  return builder_.Finish();
}

inline flatbuffers::Offset<Globalmodel> CreateGlobalmodelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *model = nullptr) {
  auto model__ = model ? _fbb.CreateString(model) : 0;
  return cotrain::CreateGlobalmodel(
      _fbb,
      model__);
}

flatbuffers::Offset<Globalmodel> CreateGlobalmodel(flatbuffers::FlatBufferBuilder &_fbb, const GlobalmodelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClientT : public flatbuffers::NativeTable {
  typedef Client TableType;
  bool upload;
  bool download;
  std::string localmodel;
  ClientT()
      : upload(false),
        download(false) {
  }
};

struct Client FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientT NativeTableType;
  typedef ClientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPLOAD = 4,
    VT_DOWNLOAD = 6,
    VT_LOCALMODEL = 8
  };
  bool upload() const {
    return GetField<uint8_t>(VT_UPLOAD, 0) != 0;
  }
  bool mutate_upload(bool _upload) {
    return SetField<uint8_t>(VT_UPLOAD, static_cast<uint8_t>(_upload), 0);
  }
  bool download() const {
    return GetField<uint8_t>(VT_DOWNLOAD, 0) != 0;
  }
  bool mutate_download(bool _download) {
    return SetField<uint8_t>(VT_DOWNLOAD, static_cast<uint8_t>(_download), 0);
  }
  const flatbuffers::String *localmodel() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALMODEL);
  }
  flatbuffers::String *mutable_localmodel() {
    return GetPointer<flatbuffers::String *>(VT_LOCALMODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UPLOAD) &&
           VerifyField<uint8_t>(verifier, VT_DOWNLOAD) &&
           VerifyOffset(verifier, VT_LOCALMODEL) &&
           verifier.VerifyString(localmodel()) &&
           verifier.EndTable();
  }
  ClientT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClientT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Client> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClientT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClientBuilder {
  typedef Client Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upload(bool upload) {
    fbb_.AddElement<uint8_t>(Client::VT_UPLOAD, static_cast<uint8_t>(upload), 0);
  }
  void add_download(bool download) {
    fbb_.AddElement<uint8_t>(Client::VT_DOWNLOAD, static_cast<uint8_t>(download), 0);
  }
  void add_localmodel(flatbuffers::Offset<flatbuffers::String> localmodel) {
    fbb_.AddOffset(Client::VT_LOCALMODEL, localmodel);
  }
  explicit ClientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientBuilder &operator=(const ClientBuilder &);
  flatbuffers::Offset<Client> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Client>(end);
    return o;
  }
};

inline flatbuffers::Offset<Client> CreateClient(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool upload = false,
    bool download = false,
    flatbuffers::Offset<flatbuffers::String> localmodel = 0) {
  ClientBuilder builder_(_fbb);
  builder_.add_localmodel(localmodel);
  builder_.add_download(download);
  builder_.add_upload(upload);
  return builder_.Finish();
}

inline flatbuffers::Offset<Client> CreateClientDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool upload = false,
    bool download = false,
    const char *localmodel = nullptr) {
  auto localmodel__ = localmodel ? _fbb.CreateString(localmodel) : 0;
  return cotrain::CreateClient(
      _fbb,
      upload,
      download,
      localmodel__);
}

flatbuffers::Offset<Client> CreateClient(flatbuffers::FlatBufferBuilder &_fbb, const ClientT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CoTrainT *CoTrain::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<cotrain::CoTrainT> _o = std::unique_ptr<cotrain::CoTrainT>(new CoTrainT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CoTrain::UnPackTo(CoTrainT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = clients(); if (_e) { _o->clients.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clients[_i] = std::unique_ptr<cotrain::ClientT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = globalmodel(); if (_e) _o->globalmodel = std::unique_ptr<cotrain::GlobalmodelT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
}

inline flatbuffers::Offset<CoTrain> CoTrain::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoTrainT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCoTrain(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CoTrain> CreateCoTrain(flatbuffers::FlatBufferBuilder &_fbb, const CoTrainT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CoTrainT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _clients = _o->clients.size() ? _fbb.CreateVector<flatbuffers::Offset<cotrain::Client>> (_o->clients.size(), [](size_t i, _VectorArgs *__va) { return CreateClient(*__va->__fbb, __va->__o->clients[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _globalmodel = _o->globalmodel ? CreateGlobalmodel(_fbb, _o->globalmodel.get(), _rehasher) : 0;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  return cotrain::CreateCoTrain(
      _fbb,
      _clients,
      _globalmodel,
      _status);
}

inline GlobalmodelT *Globalmodel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<cotrain::GlobalmodelT> _o = std::unique_ptr<cotrain::GlobalmodelT>(new GlobalmodelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Globalmodel::UnPackTo(GlobalmodelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model(); if (_e) _o->model = _e->str(); }
}

inline flatbuffers::Offset<Globalmodel> Globalmodel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobalmodelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGlobalmodel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Globalmodel> CreateGlobalmodel(flatbuffers::FlatBufferBuilder &_fbb, const GlobalmodelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GlobalmodelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model = _o->model.empty() ? 0 : _fbb.CreateString(_o->model);
  return cotrain::CreateGlobalmodel(
      _fbb,
      _model);
}

inline ClientT *Client::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<cotrain::ClientT> _o = std::unique_ptr<cotrain::ClientT>(new ClientT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Client::UnPackTo(ClientT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = upload(); _o->upload = _e; }
  { auto _e = download(); _o->download = _e; }
  { auto _e = localmodel(); if (_e) _o->localmodel = _e->str(); }
}

inline flatbuffers::Offset<Client> Client::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClientT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClient(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Client> CreateClient(flatbuffers::FlatBufferBuilder &_fbb, const ClientT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClientT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _upload = _o->upload;
  auto _download = _o->download;
  auto _localmodel = _o->localmodel.empty() ? 0 : _fbb.CreateString(_o->localmodel);
  return cotrain::CreateClient(
      _fbb,
      _upload,
      _download,
      _localmodel);
}

inline const cotrain::CoTrain *GetCoTrain(const void *buf) {
  return flatbuffers::GetRoot<cotrain::CoTrain>(buf);
}

inline const cotrain::CoTrain *GetSizePrefixedCoTrain(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cotrain::CoTrain>(buf);
}

inline CoTrain *GetMutableCoTrain(void *buf) {
  return flatbuffers::GetMutableRoot<CoTrain>(buf);
}

inline bool VerifyCoTrainBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cotrain::CoTrain>(nullptr);
}

inline bool VerifySizePrefixedCoTrainBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cotrain::CoTrain>(nullptr);
}

inline void FinishCoTrainBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cotrain::CoTrain> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCoTrainBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cotrain::CoTrain> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<cotrain::CoTrainT> UnPackCoTrain(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<cotrain::CoTrainT>(GetCoTrain(buf)->UnPack(res));
}

inline std::unique_ptr<cotrain::CoTrainT> UnPackSizePrefixedCoTrain(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<cotrain::CoTrainT>(GetSizePrefixedCoTrain(buf)->UnPack(res));
}

}  // namespace cotrain

#endif  // FLATBUFFERS_GENERATED_COTRAIN_COTRAIN_H_
